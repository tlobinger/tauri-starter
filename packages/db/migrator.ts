/**
 * Database Migration Runner
 *
 * This module handles automatic migration application at app startup.
 *
 * Migration strategy:
 * 1. Migrations are generated by drizzle-kit from schema changes
 * 2. Applied automatically when the app starts
 * 3. Migration state is tracked in SQLite's internal metadata
 * 4. Migrations are idempotent (safe to run multiple times)
 *
 * In production:
 * - This runs before the UI is shown
 * - Failures are logged and the app refuses to start
 * - This ensures data consistency
 *
 * Note: This file is designed to run in both:
 * - Development (via bun run)
 * - Production (called from Tauri startup)
 */

import { readdirSync, readFileSync } from "node:fs";
import { join } from "node:path";
import { invoke } from "@tauri-apps/api/core";

interface MigrationFile {
  name: string;
  sql: string;
}

/**
 * Load all migration files from the migrations directory
 */
function loadMigrations(): MigrationFile[] {
  const migrationsDir = join(import.meta.dir, "migrations");

  try {
    const files = readdirSync(migrationsDir)
      .filter((f) => f.endsWith(".sql"))
      .sort(); // Ensure migrations run in order

    return files.map((name) => ({
      name,
      sql: readFileSync(join(migrationsDir, name), "utf-8"),
    }));
  } catch (error) {
    console.error("Failed to load migrations:", error);
    return [];
  }
}

/**
 * Apply all pending migrations
 *
 * This function:
 * 1. Creates a migrations tracking table if needed
 * 2. Checks which migrations have been applied
 * 3. Applies pending migrations in order
 * 4. Records successful migrations
 *
 * @throws Error if any migration fails
 */
export async function runMigrations(): Promise<void> {
  console.log("üîÑ Running database migrations...");

  try {
    // Create migrations tracking table
    await invoke("execute_sql", {
      sql: `
        CREATE TABLE IF NOT EXISTS __drizzle_migrations (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          name TEXT NOT NULL UNIQUE,
          applied_at INTEGER NOT NULL
        )
      `,
      params: [],
    });

    const migrations = loadMigrations();

    if (migrations.length === 0) {
      console.log("‚úÖ No migrations to apply");
      return;
    }

    for (const migration of migrations) {
      // Check if already applied
      const result = await invoke<{ rows: Array<{ count: number }> }>("execute_sql", {
        sql: "SELECT COUNT(*) as count FROM __drizzle_migrations WHERE name = ?",
        params: [migration.name],
      });

      const alreadyApplied = result.rows[0]?.count > 0;

      if (alreadyApplied) {
        console.log(`‚è≠Ô∏è  Skipping ${migration.name} (already applied)`);
        continue;
      }

      console.log(`‚öôÔ∏è  Applying ${migration.name}...`);

      // Apply migration
      await invoke("execute_sql", {
        sql: migration.sql,
        params: [],
      });

      // Record migration
      await invoke("execute_sql", {
        sql: "INSERT INTO __drizzle_migrations (name, applied_at) VALUES (?, ?)",
        params: [migration.name, Date.now()],
      });

      console.log(`‚úÖ Applied ${migration.name}`);
    }

    console.log("‚úÖ All migrations completed successfully");
  } catch (error) {
    console.error("‚ùå Migration failed:", error);
    throw new Error(`Migration failed: ${error}`);
  }
}

/**
 * Initialize the database
 *
 * This is the main entry point called at app startup.
 * It ensures the database exists and all migrations are applied.
 */
export async function initializeDatabase(): Promise<void> {
  try {
    console.log("üöÄ Initializing database...");
    await runMigrations();
    console.log("‚úÖ Database ready");
  } catch (error) {
    console.error("‚ùå Database initialization failed:", error);
    throw error;
  }
}
